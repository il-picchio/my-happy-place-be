package tagshandler

import (
	"blenioviva/internal/models"
	"blenioviva/internal/validation"
	"encoding/json"
	"net/http"

	"github.com/gofiber/fiber/v3"
)

// CreateTagInput mirrors models.Tag except ID is omitted (generated by DB)
type CreateTagInput struct {
	Name        string              `json:"name" validate:"required,min=1,max=100"`
	Type        string              `json:"type" validate:"required,oneof=category attribute feature"`
	DisplayName models.Translations `json:"display_name" validate:"required,dive"`
	Description models.Translations `json:"description" validate:"required,dive"`
}

// CreateTag handles POST /tags
// It uses c.BodyParser to unmarshal JSON into CreateTagInput,
// then calls validation.Validate(input) to check all struct tags,
// and finally calls store.CreateTag to insert into the database.
func (h *TagsHandler) CreateTag(ctx fiber.Ctx) error {
	// 1. Parse JSON body into input struct
	var input CreateTagInput
	if err := json.Unmarshal(ctx.Body(), &input); err != nil {
		return ctx.Status(http.StatusBadRequest).JSON(fiber.Map{
			"error": "invalid JSON payload: " + err.Error(),
		})
	}

	// 2. Run your existing validator.Validate helper
	if errs, err := validation.Validate(&input); err != nil {
		// validation.Validate returns a map[field]tagError and the original error
		return ctx.Status(http.StatusBadRequest).JSON(fiber.Map{
			"error":  "validation failed",
			"fields": errs,
		})
	}
	// 3. Create the tag in the database
	created, err := h.db.CreateTag(
		ctx.Context(),
		nil,
		input.Name,
		input.Type,
		input.DisplayName,
		input.Description,
	)
	if err != nil {
		// You can detect unique constraint violations here to return 409 if desired
		return ctx.Status(http.StatusInternalServerError).JSON(fiber.Map{
			"error": err.Error(),
		})
	}

	// 4. Return 201 Created with the new tag
	return ctx.Status(http.StatusCreated).JSON(created)
}
