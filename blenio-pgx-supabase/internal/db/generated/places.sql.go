// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: places.sql

package generated

import (
	"context"

	"blenioviva/internal/models"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createPlace = `-- name: CreatePlace :exec
INSERT INTO places (
  id,
  geo,
  title,
  description,
  street,
  zip,
  city,
  state,
  country,
  photo_urls,
  created_at,
  updated_at
)
VALUES (
  $1,
  ST_MakePoint($2::float8, $3::float8),
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  $11,
  now(), now()
)
`

type CreatePlaceParams struct {
	ID          uuid.UUID           `json:"id"`
	Lng         float64             `json:"lng"`
	Lat         float64             `json:"lat"`
	Title       models.Translations `json:"title"`
	Description models.Translations `json:"description"`
	Street      string              `json:"street"`
	Zip         string              `json:"zip"`
	City        string              `json:"city"`
	State       string              `json:"state"`
	Country     string              `json:"country"`
	PhotoUrls   []string            `json:"photo_urls"`
}

func (q *Queries) CreatePlace(ctx context.Context, arg CreatePlaceParams) error {
	_, err := q.db.Exec(ctx, createPlace,
		arg.ID,
		arg.Lng,
		arg.Lat,
		arg.Title,
		arg.Description,
		arg.Street,
		arg.Zip,
		arg.City,
		arg.State,
		arg.Country,
		arg.PhotoUrls,
	)
	return err
}

const getPlaceByID = `-- name: GetPlaceByID :one
SELECT
  id,
  title,
  description,
  ST_X(geo::geometry)::float8 AS lng,
  ST_Y(geo::geometry)::float8 AS lat,
  street,
  zip,
  city,
  state,
  country,
  photo_urls
FROM places
WHERE id = $1
`

type GetPlaceByIDRow struct {
	ID          uuid.UUID           `json:"id"`
	Title       models.Translations `json:"title"`
	Description models.Translations `json:"description"`
	Lng         float64             `json:"lng"`
	Lat         float64             `json:"lat"`
	Street      string              `json:"street"`
	Zip         string              `json:"zip"`
	City        string              `json:"city"`
	State       string              `json:"state"`
	Country     string              `json:"country"`
	PhotoUrls   []string            `json:"photo_urls"`
}

func (q *Queries) GetPlaceByID(ctx context.Context, id uuid.UUID) (GetPlaceByIDRow, error) {
	row := q.db.QueryRow(ctx, getPlaceByID, id)
	var i GetPlaceByIDRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Lng,
		&i.Lat,
		&i.Street,
		&i.Zip,
		&i.City,
		&i.State,
		&i.Country,
		&i.PhotoUrls,
	)
	return i, err
}

const getPlacesFilteredNoCoords = `-- name: GetPlacesFilteredNoCoords :many
SELECT
  p.id,
  p.title,
  p.description,
  ST_X(p.geo::geometry)::float8 AS lng,
  ST_Y(p.geo::geometry)::float8 AS lat,
  p.street,
  p.zip,
  p.city,
  p.state,
  p.country,
  p.photo_urls,
  NULL::float8 AS distance
FROM places AS p
WHERE
  -- Keyset pagination by id
  (
    $1 IS NULL
    OR p.id > $1
  )
  AND
  -- Tag filtering: require every tag_id in @tag_ids
  (
    $2 IS NULL
    OR $2 = '{}'
    OR NOT EXISTS (
      SELECT required.tag_id
      FROM unnest($2) AS required(tag_id)
      WHERE NOT EXISTS (
        SELECT 1
        FROM place_tags AS pt
        WHERE pt.place_id = p.id
          AND pt.tag_id = required.tag_id
      )
    )
  )
  AND
  -- Opening hours filter
  (
    $3 IS NULL
    OR $4 IS NULL
    OR EXISTS (
      SELECT 1
      FROM place_opening_hours AS oh
      WHERE oh.place_id = p.id
        AND oh.day_of_week = $3
        AND $4 >= oh.open_time
        AND $4 <  oh.close_time
    )
  )
ORDER BY p.id ASC
LIMIT 20
`

type GetPlacesFilteredNoCoordsParams struct {
	LastID    interface{} `json:"last_id"`
	TagIds    interface{} `json:"tag_ids"`
	DayOfWeek interface{} `json:"day_of_week"`
	TimeOfDay interface{} `json:"time_of_day"`
}

type GetPlacesFilteredNoCoordsRow struct {
	ID          uuid.UUID           `json:"id"`
	Title       models.Translations `json:"title"`
	Description models.Translations `json:"description"`
	Lng         float64             `json:"lng"`
	Lat         float64             `json:"lat"`
	Street      string              `json:"street"`
	Zip         string              `json:"zip"`
	City        string              `json:"city"`
	State       string              `json:"state"`
	Country     string              `json:"country"`
	PhotoUrls   []string            `json:"photo_urls"`
	Distance    pgtype.Float8       `json:"distance"`
}

// Fetch places ordered by id + keyset pagination, filtered by tags and opening hours.
// Parameters:
//
//	@last_id        : uuid     — last place.id from previous page (pass NULL for first page)
//	@tag_ids        : uuid[]   — array of tag IDs that the place must have (pass NULL or '{}' to ignore)
//	@day_of_week    : int4     — integer 0=Sunday … 6=Saturday (pass NULL to ignore)
//	@time_of_day    : time     — time in HH:MM:SS (pass NULL to ignore)
func (q *Queries) GetPlacesFilteredNoCoords(ctx context.Context, arg GetPlacesFilteredNoCoordsParams) ([]GetPlacesFilteredNoCoordsRow, error) {
	rows, err := q.db.Query(ctx, getPlacesFilteredNoCoords,
		arg.LastID,
		arg.TagIds,
		arg.DayOfWeek,
		arg.TimeOfDay,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPlacesFilteredNoCoordsRow{}
	for rows.Next() {
		var i GetPlacesFilteredNoCoordsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Lng,
			&i.Lat,
			&i.Street,
			&i.Zip,
			&i.City,
			&i.State,
			&i.Country,
			&i.PhotoUrls,
			&i.Distance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlacesNearbyWithCoords = `-- name: GetPlacesNearbyWithCoords :many
WITH nearest AS (
  SELECT
    p.id,
    p.title,
    p.description,
    ST_X(p.geo::geometry)::float8 AS lng,
    ST_Y(p.geo::geometry)::float8 AS lat,
    p.street,
    p.zip,
    p.city,
    p.state,
    p.country,
    p.photo_urls,
    p.geo
  FROM places AS p
  ORDER BY p.geo::geometry <-> ST_SetSRID(ST_MakePoint($1::float8, $2::float8), 4326)
  LIMIT 200
)
SELECT
  n.id,
  n.title,
  n.description,
  n.lng,
  n.lat,
  n.street,
  n.zip,
  n.city,
  n.state,
  n.country,
  n.photo_urls,
  ST_Distance(n.geo, ST_SetSRID(ST_MakePoint($1::float8, $2::float8), 4326))::float8 AS distance
FROM nearest AS n
WHERE
  -- Cursor pagination by distance
  (
    $3 IS NULL
    OR ST_Distance(n.geo, ST_SetSRID(ST_MakePoint($1::float8, $2::float8), 4326)) > $3
  )
  AND
  -- Max distance filter
  (
    $4 IS NULL
    OR ST_Distance(n.geo, ST_SetSRID(ST_MakePoint($1::float8, $2::float8), 4326)) <= $4
  )
  AND
  -- Tag filtering: require every tag_id in @tag_ids
  (
    $5 IS NULL
    OR $5 = '{}'
    OR NOT EXISTS (
      SELECT required.tag_id
      FROM unnest($5) AS required(tag_id)
      WHERE NOT EXISTS (
        SELECT 1
        FROM place_tags AS pt
        WHERE pt.place_id = n.id
          AND pt.tag_id = required.tag_id
      )
    )
  )
  AND
  -- Opening hours filter
  (
    $6 IS NULL
    OR $7 IS NULL
    OR EXISTS (
      SELECT 1
      FROM place_opening_hours AS oh
      WHERE oh.place_id = n.id
        AND oh.day_of_week = $6
        AND $7 >= oh.open_time
        AND $7 <  oh.close_time
    )
  )
ORDER BY distance ASC, id ASC
LIMIT 20
`

type GetPlacesNearbyWithCoordsParams struct {
	Lng          float64     `json:"lng"`
	Lat          float64     `json:"lat"`
	LastDistance interface{} `json:"last_distance"`
	MaxDistance  interface{} `json:"max_distance"`
	TagIds       interface{} `json:"tag_ids"`
	DayOfWeek    interface{} `json:"day_of_week"`
	TimeOfDay    interface{} `json:"time_of_day"`
}

type GetPlacesNearbyWithCoordsRow struct {
	ID          uuid.UUID           `json:"id"`
	Title       models.Translations `json:"title"`
	Description models.Translations `json:"description"`
	Lng         float64             `json:"lng"`
	Lat         float64             `json:"lat"`
	Street      string              `json:"street"`
	Zip         string              `json:"zip"`
	City        string              `json:"city"`
	State       string              `json:"state"`
	Country     string              `json:"country"`
	PhotoUrls   []string            `json:"photo_urls"`
	Distance    float64             `json:"distance"`
}

// Find places near a given point, using distance sorting + cursor pagination,
// filtered by matching all provided tags and by opening hours.
// Parameters:
//
//	@lng            : float8    — reference longitude
//	@lat            : float8    — reference latitude
//	@last_distance  : float8    — distance cursor for pagination (pass NULL for first page)
//	@max_distance   : float8    — maximum distance filter (meters) (pass NULL to ignore)
//	@tag_ids        : uuid[]    — array of tag IDs that the place must have (pass NULL or '{}' to ignore)
//	@day_of_week    : int4      — integer 0=Sunday … 6=Saturday (pass NULL to ignore)
//	@time_of_day    : time      — time in HH:MM:SS (pass NULL to ignore)
func (q *Queries) GetPlacesNearbyWithCoords(ctx context.Context, arg GetPlacesNearbyWithCoordsParams) ([]GetPlacesNearbyWithCoordsRow, error) {
	rows, err := q.db.Query(ctx, getPlacesNearbyWithCoords,
		arg.Lng,
		arg.Lat,
		arg.LastDistance,
		arg.MaxDistance,
		arg.TagIds,
		arg.DayOfWeek,
		arg.TimeOfDay,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPlacesNearbyWithCoordsRow{}
	for rows.Next() {
		var i GetPlacesNearbyWithCoordsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Lng,
			&i.Lat,
			&i.Street,
			&i.Zip,
			&i.City,
			&i.State,
			&i.Country,
			&i.PhotoUrls,
			&i.Distance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePlacePartial = `-- name: UpdatePlacePartial :exec
UPDATE places
SET
  title = COALESCE($1, title),
  description = COALESCE($2, description),
  geo = CASE
          WHEN $3 IS NOT NULL AND $4 IS NOT NULL
          THEN ST_SetSRID(ST_MakePoint($3::float8, $4::float8), 4326)
          ELSE geo
        END,
  street = COALESCE($5, street),
  zip = COALESCE($6, zip),
  city = COALESCE($7, city),
  state = COALESCE($8, state),
  country = COALESCE($9, country),
  photo_urls = COALESCE($10, photo_urls),
  updated_at = now()
WHERE id = $11
`

type UpdatePlacePartialParams struct {
	Title       models.Translations `json:"title"`
	Description models.Translations `json:"description"`
	Lng         interface{}         `json:"lng"`
	Lat         interface{}         `json:"lat"`
	Street      string              `json:"street"`
	Zip         string              `json:"zip"`
	City        string              `json:"city"`
	State       string              `json:"state"`
	Country     string              `json:"country"`
	PhotoUrls   []string            `json:"photo_urls"`
	ID          uuid.UUID           `json:"id"`
}

func (q *Queries) UpdatePlacePartial(ctx context.Context, arg UpdatePlacePartialParams) error {
	_, err := q.db.Exec(ctx, updatePlacePartial,
		arg.Title,
		arg.Description,
		arg.Lng,
		arg.Lat,
		arg.Street,
		arg.Zip,
		arg.City,
		arg.State,
		arg.Country,
		arg.PhotoUrls,
		arg.ID,
	)
	return err
}
