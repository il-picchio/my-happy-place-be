// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tags.sql

package generated

import (
	"context"

	"blenioviva/internal/models"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createTag = `-- name: CreateTag :one
INSERT INTO tags (name, display_name, type, description)
VALUES ($1, $2, $3, $4)
RETURNING id, name, display_name, type, description, deprecated, created_at, updated_at
`

type CreateTagParams struct {
	Name        string              `json:"name"`
	Displayname models.Translations `json:"displayname"`
	Type        string              `json:"type"`
	Description models.Translations `json:"description"`
}

type CreateTagRow struct {
	ID          uuid.UUID           `json:"id"`
	Name        string              `json:"name"`
	DisplayName models.Translations `json:"display_name"`
	Type        string              `json:"type"`
	Description models.Translations `json:"description"`
	Deprecated  bool                `json:"deprecated"`
	CreatedAt   pgtype.Timestamptz  `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz  `json:"updated_at"`
}

// Query to insert a new tag and return all columns
func (q *Queries) CreateTag(ctx context.Context, arg CreateTagParams) (CreateTagRow, error) {
	row := q.db.QueryRow(ctx, createTag,
		arg.Name,
		arg.Displayname,
		arg.Type,
		arg.Description,
	)
	var i CreateTagRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DisplayName,
		&i.Type,
		&i.Description,
		&i.Deprecated,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM tags
WHERE id = $1
`

// Permanently delete a tag by its ID.
func (q *Queries) DeleteTag(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteTag, id)
	return err
}

const deprecateTag = `-- name: DeprecateTag :one
UPDATE tags
SET deprecated = TRUE,
    updated_at = now()
WHERE id = $1
RETURNING
  id,
  name,
  display_name,
  type,
  description,
  deprecated,
  created_at,
  updated_at
`

type DeprecateTagRow struct {
	ID          uuid.UUID           `json:"id"`
	Name        string              `json:"name"`
	DisplayName models.Translations `json:"display_name"`
	Type        string              `json:"type"`
	Description models.Translations `json:"description"`
	Deprecated  bool                `json:"deprecated"`
	CreatedAt   pgtype.Timestamptz  `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz  `json:"updated_at"`
}

// Mark a tag as deprecated.
func (q *Queries) DeprecateTag(ctx context.Context, id uuid.UUID) (DeprecateTagRow, error) {
	row := q.db.QueryRow(ctx, deprecateTag, id)
	var i DeprecateTagRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DisplayName,
		&i.Type,
		&i.Description,
		&i.Deprecated,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllTagsByType = `-- name: GetAllTagsByType :many
SELECT
  id,
  name,
  display_name,
  type,
  description,
  deprecated,
  created_at,
  updated_at
FROM tags
WHERE type = $1
  AND (deprecated = FALSE OR $2::boolean)
ORDER BY name
`

type GetAllTagsByTypeParams struct {
	Type              string `json:"type"`
	Includedeprecated bool   `json:"includedeprecated"`
}

type GetAllTagsByTypeRow struct {
	ID          uuid.UUID           `json:"id"`
	Name        string              `json:"name"`
	DisplayName models.Translations `json:"display_name"`
	Type        string              `json:"type"`
	Description models.Translations `json:"description"`
	Deprecated  bool                `json:"deprecated"`
	CreatedAt   pgtype.Timestamptz  `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz  `json:"updated_at"`
}

// Fetch all tags of a given type, optionally including deprecated ones.
func (q *Queries) GetAllTagsByType(ctx context.Context, arg GetAllTagsByTypeParams) ([]GetAllTagsByTypeRow, error) {
	rows, err := q.db.Query(ctx, getAllTagsByType, arg.Type, arg.Includedeprecated)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllTagsByTypeRow{}
	for rows.Next() {
		var i GetAllTagsByTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.DisplayName,
			&i.Type,
			&i.Description,
			&i.Deprecated,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagByExactName = `-- name: GetTagByExactName :one
SELECT
  id,
  name,
  display_name,
  type,
  description,
  deprecated,
  created_at,
  updated_at
FROM tags
WHERE name = $1
  AND (deprecated = FALSE OR $2::boolean)
`

type GetTagByExactNameParams struct {
	Name              string `json:"name"`
	Includedeprecated bool   `json:"includedeprecated"`
}

type GetTagByExactNameRow struct {
	ID          uuid.UUID           `json:"id"`
	Name        string              `json:"name"`
	DisplayName models.Translations `json:"display_name"`
	Type        string              `json:"type"`
	Description models.Translations `json:"description"`
	Deprecated  bool                `json:"deprecated"`
	CreatedAt   pgtype.Timestamptz  `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz  `json:"updated_at"`
}

// Fetch a single tag by exact name, optionally including deprecated.
func (q *Queries) GetTagByExactName(ctx context.Context, arg GetTagByExactNameParams) (GetTagByExactNameRow, error) {
	row := q.db.QueryRow(ctx, getTagByExactName, arg.Name, arg.Includedeprecated)
	var i GetTagByExactNameRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DisplayName,
		&i.Type,
		&i.Description,
		&i.Deprecated,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTagsLike = `-- name: GetTagsLike :many
SELECT
  id,
  name,
  display_name,
  type,
  description,
  deprecated,
  created_at,
  updated_at
FROM tags
WHERE (
      name ILIKE '%' || $1 || '%'
   OR EXISTS (
         SELECT 1
         FROM jsonb_each_text(display_name) AS kv(key, value)
         WHERE value ILIKE '%' || $1 || '%'
      )
   OR EXISTS (
         SELECT 1
         FROM jsonb_each_text(description) AS kv(key, value)
         WHERE value ILIKE '%' || $1 || '%'
      )
  )
  AND (deprecated = FALSE OR $2::boolean)
ORDER BY
  (name ILIKE $1 || '%') DESC,
  name
`

type GetTagsLikeParams struct {
	Term              pgtype.Text `json:"term"`
	Includedeprecated bool        `json:"includedeprecated"`
}

type GetTagsLikeRow struct {
	ID          uuid.UUID           `json:"id"`
	Name        string              `json:"name"`
	DisplayName models.Translations `json:"display_name"`
	Type        string              `json:"type"`
	Description models.Translations `json:"description"`
	Deprecated  bool                `json:"deprecated"`
	CreatedAt   pgtype.Timestamptz  `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz  `json:"updated_at"`
}

// Search tags by partial name, any display_name value, or any description value (across all languages),
// optionally including deprecated ones.
func (q *Queries) GetTagsLike(ctx context.Context, arg GetTagsLikeParams) ([]GetTagsLikeRow, error) {
	rows, err := q.db.Query(ctx, getTagsLike, arg.Term, arg.Includedeprecated)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTagsLikeRow{}
	for rows.Next() {
		var i GetTagsLikeRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.DisplayName,
			&i.Type,
			&i.Description,
			&i.Deprecated,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTag = `-- name: UpdateTag :one
UPDATE tags
SET
  name = COALESCE($1, name),
  display_name = COALESCE($2, display_name),
  type = COALESCE($3, type),
  description = COALESCE($4, description),
  deprecated = COALESCE($5, deprecated),
  updated_at = now()
WHERE id = $6
RETURNING
  id,
  name,
  display_name,
  type,
  description,
  deprecated,
  created_at,
  updated_at
`

type UpdateTagParams struct {
	Name        string              `json:"name"`
	DisplayName models.Translations `json:"display_name"`
	Type        string              `json:"type"`
	Description models.Translations `json:"description"`
	Deprecated  bool                `json:"deprecated"`
	ID          uuid.UUID           `json:"id"`
}

type UpdateTagRow struct {
	ID          uuid.UUID           `json:"id"`
	Name        string              `json:"name"`
	DisplayName models.Translations `json:"display_name"`
	Type        string              `json:"type"`
	Description models.Translations `json:"description"`
	Deprecated  bool                `json:"deprecated"`
	CreatedAt   pgtype.Timestamptz  `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz  `json:"updated_at"`
}

// Update only the provided fields for a specific tag; leave others unchanged.
func (q *Queries) UpdateTag(ctx context.Context, arg UpdateTagParams) (UpdateTagRow, error) {
	row := q.db.QueryRow(ctx, updateTag,
		arg.Name,
		arg.DisplayName,
		arg.Type,
		arg.Description,
		arg.Deprecated,
		arg.ID,
	)
	var i UpdateTagRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DisplayName,
		&i.Type,
		&i.Description,
		&i.Deprecated,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
